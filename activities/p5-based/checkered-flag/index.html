<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Checkered flag</title>
    <script src="/custom-elements/custom-navbar.js"></script>
    <script src="/custom-elements/custom-badges.js"></script>
    <script src="/custom-elements/custom-guizero.js"></script>
    <script type="module" src="/custom-elements/custom-code-block.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.1/lib/p5.min.js"></script>
    <script src="/custom-elements/custom-copyright.js"></script>
    <link rel="stylesheet" href="/style.css">
</head>

<body class="container">

    <cc-navbar active="p5" level="3" />

    <h1>Checkered flag
        <cc-badge-hard/>
    </h1>

    <h2 style="color: red;">UNDER CONSTRUCTION - UNDER CONSTRUCTION - UNDER CONSTRUCTION</h2>

    <section>
        <h2>What will I make?</h2>

        <p>An animation with a wavy checkered flag.</p>

        <!-- 
from p5 import *
from dot import Dot

NCOLS = 16 + 1
NROWS = 16 + 1
MARGIN = 30
SPEED = 2

dots = []

def setup():
    size(400, 400)

    total_width = width - 2 * MARGIN
    total_height = height - 2 * MARGIN

    width_one = total_width / NCOLS
    height_one = total_height / NROWS

    for col in range(NCOLS):
        dots.append([])
        for row in range(NROWS):
            radius = min(width_one, height_one) / 2 * 0.9
            angle = radians((col + row) * 20)
            dots[col].append(Dot(
                cx=MARGIN + (col + 0.5) * width_one,
                cy=MARGIN + (row + 0.5) * height_one,
                radius=radius,
                angle=angle,
                speed=SPEED,
                color="red"
            ))

def draw():
    background(0)
    for col in range(NCOLS):
        for row in range(NROWS):
            dots[col][row].update()

    # Fill the cells.
    no_stroke()
    for row in range(NROWS-1):
        for col in range(NCOLS-1):
            a = dots[col][row]
            b = dots[col+1][row]
            c = dots[col+1][row+1]
            d = dots[col][row+1]
            fill(color_for_cell(col, row, "green", "white"))            
            quad(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y)

    # Draw the vertical lines.
    stroke("black")
    for col in range(NCOLS):
        for row in range(NROWS-1):
            a = dots[col][row]
            b = dots[col][row+1]
            line(a.x, a.y, b.x, b.y)

    # Draw the horizontal lines.
    stroke("black")
    for row in range(NROWS):
        for col in range(NCOLS-1):
            a = dots[col][row]
            b = dots[col+1][row]
            line(a.x, a.y, b.x, b.y)

    # # Display the dots.
    # for col in range(NCOLS):
    #     for row in range(NROWS):
    #         dots[col][row].display(debug=True)

def color_for_cell(col, row, color1="black", color2="white"):
    # return color1 if col % 2 == 0 else color2  # vertical stripes
    # return color1 if row % 2 == 0 else color2  # horizontal stripes
    return color1 if (col + row) % 2 == 0 else color2  # checkerboard

from p5 import *
from math import cos, sin

class Dot:
    def __init__(self, cx, cy, radius, angle, speed, color):
        self.cx = cx
        self.cy = cy
        self.radius = radius
        self.diameter = 2 * self.radius
        self.angle = angle
        self.speed = speed
        self.color = color

    def update(self):
        self.angle += radians(self.speed)
        self.x = self.cx + self.radius * cos(self.angle)
        self.y = self.cy + self.radius * sin(self.angle)

    def display(self, debug=False):
        push_style()

        if debug:
            fill(255, 75)
            circle(self.cx, self.cy, self.diameter)
            line(self.cx, self.cy, self.x, self.y)
            circle(self.x, self.y, 2)
            
        stroke(self.color)
        stroke_weight(5)
        point(self.x, self.y)
        
        pop_style()

run()
        -->

        <div id="p5-checkered-flag"></div>

        <script>
            new p5(p => {
                const NCOLS = 16 + 1;
                const NROWS = 16 + 1;
                const MARGIN = 30;
                const SPEED = 2;

                let dots = [];

                p.setup = function() {
                    p.createCanvas(400, 400);

                    let total_width = p.width - 2 * MARGIN;
                    let total_height = p.height - 2 * MARGIN;

                    let width_one = total_width / NCOLS;
                    let height_one = total_height / NROWS;

                    for (let col = 0; col < NCOLS; col++) {
                        dots.push([]);
                        for (let row = 0; row < NROWS; row++) {
                            let radius = Math.min(width_one, height_one) / 2 * 0.9;
                            let angle = p.radians((col + row) * 20);
                            dots[col].push(new Dot(
                                MARGIN + (col + 0.5) * width_one,
                                MARGIN + (row + 0.5) * height_one,
                                radius,
                                angle,
                                SPEED,
                                "red"
                            ));
                        }
                    }
                };

                p.draw = function() {
                    p.background(0);
                    for (let col = 0; col < NCOLS; col++) {
                        for (let row = 0; row < NROWS; row++) {
                            dots[col][row].update();
                        }
                    }

                    // Fill the cells.
                    p.noStroke();
                    for (let row = 0; row < NROWS - 1; row++) {
                        for (let col = 0; col < NCOLS - 1; col++) {
                            let a = dots[col][row];
                            let b = dots[col + 1][row];
                            let c = dots[col + 1][row + 1];
                            let d = dots[col][row + 1];
                            p.fill(color_for_cell(col, row, "green", "white"));
                            p.quad(a.x, a.y, b.x, b.y, c.x, c.y, d.x, d.y);
                        }
                    }

                    // Draw the vertical lines.
                    p.stroke("black");
                    for (let col = 0; col < NCOLS; col++) {
                        for (let row = 0; row < NROWS - 1; row++) {
                            let a = dots[col][row];
                            let b = dots[col][row + 1];
                            p.line(a.x, a.y, b.x, b.y);
                        }
                    }

                    // Draw the horizontal lines.
                    p.stroke("black");
                    for (let row = 0; row < NROWS; row++) {
                        for (let col = 0; col < NCOLS - 1; col++) {
                            let a = dots[col][row];
                            let b = dots[col + 1][row];
                            p.line(a.x, a.y, b.x, b.y);
                        }
                    }

                    // // Display the dots.
                    // for (let col = 0; col < NCOLS; col++) {
                    //     for (let row = 0; row < NROWS; row++) {
                    //         dots[col][row].display(true);
                    //     }
                    // }

                    function color_for_cell(col, row, color1 = "black", color2 = "white") {
                        // return color1 if col % 2 == 0 else color2;  // vertical stripes
                        // return color1 if row % 2 == 0 else color2;  // horizontal stripes
                        return (col + row) % 2 == 0 ? color1 : color2;  // checkerboard
                    }
                };

                class Dot {
                    constructor(cx, cy, radius, angle, speed, color) {
                        this.cx = cx;
                        this.cy = cy;
                        this.radius = radius;
                        this.diameter = 2 * this.radius;
                        this.angle = angle;
                        this.speed = speed;
                        this.color = color;
                    }

                    update() {
                        this.angle += p.radians(this.speed);
                        this.x = this.cx + this.radius * p.cos(this.angle);
                        this.y = this.cy + this.radius * p.sin(this.angle);
                    }

                    display(debug = false) {
                        p.push();
                        if (debug) {
                            p.fill(255, 75);
                            p.circle(this.cx, this.cy, this.diameter);
                            p.line(this.cx, this.cy, this.x, this.y);
                            p.circle(this.x, this.y, 2);
                        }
                        p.stroke(this.color);
                        p.strokeWeight(5);
                        p.point(this.x, this.y);
                        p.pop();
                    }
                }
            }, "p5-checkered-flag");
        </script>
    </section>

    <section>
        <h2>Instructions</h2>
        <ol>
            <li>Open the <a href="https://editor.raspberrypi.org/en/projects/ajar-plank-most" target="_blank">starter project</a> and click the <strong>Run</strong> button.</li>
            <li>Login to be able to save your work.</li>
            <li>...</li>
        </ol>
    </section>

    <section>
        <h2>What can I try next?</h2>
        <p>...</p>
        <!--
        <p>Here are some things you can try to make the app better. They are independent from each other so you can pick just a couple or do them in a different order. If you get stuck, use the <em>Hints</em> button or read the Guizero documentation (see <a href="../index.html">Build an app with Guizero</a>).</p>
        <p>And of course you can also use your imagination and change the app as you like!</p>
        <ul>
            <li>Add a button to <strong>change the background color</strong>.
                <ol>
                    <li>Create a new <cc-gz-pushbutton/> with <code>text="Background"</code> (or an image) and linked to the <code>on_background</code> callback function.</li>
                    <li>Create a new <code>on_background</code> callback function to change the background color of <code>output_text</code>.</li>
                    <details class="hints">
                        <summary>Hints</summary>
                        <ul>
                            <li>Check the existing <code>on_color</code> callback function. It does almost what you need but it changes the foreground color instead of the background color.</li>
                            <li>Check the documentation for <cc-gz-textbox/> and find the property you need to change.</li>
                        </ul>
                    </details>
                </ol>
            </li>
        </ul>
        -->
    </section>

    <cc-copyright></cc-copyright>
</body>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>

</html>
